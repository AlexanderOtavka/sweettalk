-- sweettalk Programming Language Spec Draft
-- This is a very rough and informal working spec, just to get my ideas written
-- down.

-- sweettalk is a dynamically typed functional language similar to python and
-- JavaScript. It is meant to interop well with other languages, not requiring
-- user generated bindings. The function call syntax is inspired by smalltalk,
-- hence the name. It is meant to be verbose and read very close to english.
-- Built-in support for reactivity is a maybe.

-- For now, it will be compile to JS, but eventually, it should compile to an IR
-- that can target arbitrary environments. The standard library will be designed
-- to be very portable, and to favor dependency injection of platform specific
-- things.

-------- How indentation works:

-- a colon wraps all following and indented expressions with parens, similar to
-- $ operator in Haskell.
do (complicated expression with nesting).
-- same as
do: complicated expression with nesting.
-- same as
do:
  complicated expression with nesting.

-- Equals sign does the same to parsing, but indicates assignment
the definition = complicated expression with nesting.
-- same as
the definition =
  complicated expression with nesting.

-- Multiple colons or equals signs on one line are okay
the definition =
  complicated expression with a sub_expression:
    Sub Expression.
-- same as
the definition = complicated expression with a sub_expression:
  Sub Expression.

-------- How function definitions work:

-- Define a function

-- Simple function:
write a string to a file =
  ----
  This is interpreted as function documentation. Four or more dashes open a
  multi-line comment, and the same number close it.

  'the string' will be written to 'the file'. 'the file' must have an
  associated file descriptor.
  ----

  the system_box's write to a file_descriptor:
    [unwrapped] the system_box's f'n 'optional descriptor of a file'(the file)
      -- [unwrapped] crashes if option is nothing
  from an array_buffer:
    the memory_box's ArrayBuffer from the string.

write a string (a renamed_string) to a file (a renamed_file) = -- ...

-- Excluding argument names from function name
map (a transform) onto a list = -- is named map onto a list
map onto list (Transform, List) =>
map (Transform) onto (List) list =>

-- Optional parameters
say (Message? or "\n") =>

-- `?!` crashes if the maybe is nothing.
-- `?` returns early with the maybe if it is bad

-- Overloads
-- Not really overloads because it generates multiple functions with different
-- names, but with the same body.  Come up with a better name
do a thing (and another one (a third with the other one)?)?
    (or a fourth independently with Parameter)? (is_ ok)? =>
        -- this function simply prints out the way it was called
        (
            if And Another One -- We can see which branch we took
                then: "and another one" ++
                    if A Third With The Other One
                        -- This one is nested, so it can only be given if `And
                        -- Another One` is given first
                        then "a third with the other one"
                        else ""
                else ""
        ) ++ (
            if Or A Fourth Independently With Parameter
                then "or a fourth independently with parameter ($(Parameter?!))"
                else ""
        ) ++ (
            if Is_ Ok -- use underscore to avoid confusion with keyword
                then "is_ ok"
                else ""
        )

-- Annotating parameters with types
write String [is string] to File [is system::io::file] =>
map onto list [Transform [is (any) => any], List [is list (any)] =>
print Things [are any] =>
print Things [is list (any)] =>
print things (Things [is list (any)]) =>

-------- How function calls work:

-- Call by order:
let File = system::io:: open file "./foo.txt" until closed
let String = "foo"
let Other_String = "bar"

write String to File                -- when the names match
write string (Other_String) to File -- when the names don't match, or you need to nest an expression
write String to file (File)         -- you can even do it this way even if the names do match, but it's longer
write string "baz" to File          -- no parens needed if you pass a literal
write string to file (String, File) -- c style
write (String, File) string to file -- the parens can really go anywhere after the first word, as long as the arguments stay in order

-- BAD
write string to file (String) (File) -- can't do this, there must be a word between each group of parens.
                                     -- This is a syntax error to avoid ambiguity
-- If you want to call curried functions, do
(curried "foo") ("bar")

-- Call by name:
write string to file {String = Other_String, File = File} -- keyed by the argument names
write string to file {String, File} -- if the names match, pass by name
write string to file {File, String} -- order doesn't matter

-- BAD
write string {String = Other_String} to {File} file -- curly braces must go at end!

-- Call by order and name:
write String to file {File = File} -- you can combine order and name
write string to file (String) {File = File}

-- Referencing a function:
handle Event [returns nothing] => log message "x: [Event->x], y: [Event->y]"
www::dom:: when dom_event "click" happens do: Handle Event

-- Assigning a function to a variable
-- Functions are just values, this is a functional programming language after all
-- Capitalize all the words in the function name to reference or assign to it
Task Is Done = ->Is_Done

-------- Type constructors

type maybe = one of:
    something *
    nothing

type result = one of:
    ok *
    error *

let My_Something = maybe something 5
let My_Something = maybe something (3 + 2)
let My_Nothing = maybe nothing

let My_Result = result ok 5

crash! unless My_Result is result
crash! unless My_Something is maybe

if My_Something is maybe something (Thing)
    then: log message "Something: $Thing"
    elsif My_Something == 2
    then: log message "Technically possible, because we aren't statically typed"
    else: log message "Nothing"

if My_Result is result ok (Thing)
    then: log message "Ok: $Thing"
    else:
        let result error (Error) = My_Result
        log message "Error: $Error"

----------------
| Example code |
----------------

open box "https://sweetshoppe.io/HTTP/2.1.2/_.sweet".

from box "https://npm.org/modules/fs/1.0.0/index.js" use:
  the f'n 'write' as the f'n 'write a string to a file'.

use box "https://npm.org/modules/React/16.2.1/lib.js" as the react_box.

share box "https://mycode.com/Task_Utils.sweet".

from box "https://mycode.com/Table_Utils.sweet" share:
  the f'n 'normalized form of a table'.

share:
  the f'n 'string format of a list_table',
  the f'n 'a task is done',
  the str.

do:
  log message "This runs on startup when this module is imported".
  log message "The module was used with an injected dependency "
              "[the function_name]".
  clarifying:
    the function_name = name of a function:
      the f'n 'promised HTTP Response from fetching a url'.

  let the tasks =
    response from requesting uri "https://api.tasks.io/tasks"
      |>  value from that json_string.
  let the formatted_table = string format of a list_table: List:
    Array: "#", "Done", "Text",
    Array: "1", "\[X]",  "Design a programming language",
    Array: "2", "\[ ]",  "Implement that programming language".

[shared] run program =
  write a string (the formatted_table) to a file (the stdout_file).

  clarifying:
    the tasks =
      promised HTTP Response from fetching url "https://api.tasks.io/tasks"
        |>  that [awaited] thing
        |>  that thing's body
        |>  value from that json_string.

    the formatted_table = string format of a list_table: List:
      Array: "#", "Done", "Text",

      ...an iterable (the tasks) with each element passed through
      an enumerated_transform: a f'n 'row from a task at an index':
        Array:
          string from a number (the index + 1),
          "\[[the x]]",
          the task's text.

        clarifying: the x = is the task not done? then " ", otherwise "X".

the f'n 's value' = 22_335.3 / 0.88 * 5 - the react_box's f'n 'not_real'().

a task is done = Boolean: the task's is_done

string value = "hello there"
the str = `"foo" bar \n [string value]`

element at an index of an array = the array's #(the index).
first element of an array = the array's #0.

[html element] div with children (...the child_list) {
  a class,
  an [unused] className,
  ...[Object] a property_map -- object is the default anyway
} =
  the react_box's createElement("div", an object {
    the className = the class,
    ...the property_map
  })

-- The standard library won't do indexes with its function.
an iterable with each element passed through
an enumerated_transform (a f'n 'an element transformed at an index of an
iterable') =
  ------------------------------------------------------------------------------
  This is just like Array#map in JavaScript. The transform should accept both
  an element and an index.
  ------------------------------------------------------------------------------

  the iterable at index 0 with each element transformed.

  clarifying:
    an iterable at an index with each element transformed =
      does the iterable match:
        ()? then the iterable,

        (the first_element, ...the other_elements)? then
          the iterable_box's an element:
            the element transformed at the index of the iterable.
            clarifying: the element = the first_element
          in front of an iterable:
            an iterable (the other_elements) at an index (the index + 1) with
            each element transformed.

string format of a list_table =
    does the list_table match:
      ()? then "",

      (the first_row, ...the other_rows)? then
        "| [the inner_row_contents] |\n[the rest]".

        clarifying:
          the inner_row_contents =
            string joining a list (the first row) with separator " | ".

          the rest = string format of a list_table (the other_rows).

-- JS equivalent
-- function formatListTable(table) {
--     if (table.length == 0) {
--         return ""
--     } else {
--         const [firstRow, ...otherRows] = table
--         return `| ${firstRow.join(" | ")} |\n` + formatArrayTable(otherRows)
--     }
-- }

---------------------------------------
| A simple web server standalone file |
---------------------------------------

--  Tasks_Server.sweet  --

open box "https://sweetshoppe.io/Waitress/1.0.0/_.sweet".
----
shares:
- the f'n 'Waitress'
- the f'n 'start a waitress at a port'
- the f'n 'a waitress passing all requests through a middleware'
- the f'n 'a waitress responding to get requests at a path
  with a response_function'
- the f'n 'response from running a waitress_middleware_chain with a request'
shares from "https://sweetshoppe.io/HTTP/1.0.0/_.sweet":
- the f'n 'HTTP Request {...}'
- the f'n 'HTTP Response with a header_list and a json_body'
- the f'n 'HTTP Headers {...}'
- the f'n 'an http_request with extra {...}'
----

open box "https://sweetshoppe.io/Postgres/2.3.3/_.sweet".
----
shares:
- the f'n 'Postgres Connection with a uri {an [optional] username,
  an [optional] password}'
- the f'n 'close a postgres_connection'
shares from "https://sweetshoppe.io/SQL/1.0.0/_.sweet":
- the f'n 'sql (a template_tree)'
----

[shared] run program = start the waitress at port 3000.

the waitress = Waitress
  |>  that waitress passing all requests through a middleware: the db_middleware

  |>  that waitress handling get requests at a path (path to tasks)
      with a response_function: a f'n 'response from a request':
        HTTP Response to the request
        with the header_list and a json_body (the task_list).

        clarifying:
          the header_list = HTTP Headers:
            "Link" = link header with rel "next" to a uri:
              path to tasks {the page_token = the next_page_token}.
          the next_page_token = json from a value:
            Array (the last_task's due_date, the last_task's id).

          the last_task = last element of a list (the task_list).
          the task_list =
            object list from the postgres_connection given a sql_query:
              sql<-"
                select * from tasks
                where
                  due_date > [the page_due_date] and
                  id > [the page_id]
                order by
                  due_date asc,
                  id asc
                limit [the page_size]
              ".
          (the page_due_date, the page_id) =
            value from a json_string (the page_token)'s.

          {the page_token, the [default 10] page_size} = the request's query's.
          {the postgres_connection} = the request's extra's.

the db_middleware =
  a f'n 'middleware with a request and a waitress_middleware_chain':
    do:
      let the response =
        response from running the waitress_middleware_chain
        with a request (the modified_request).
      close the postgres_connection.
      return the response.

    clarifying:
      the modified_request =
        an http_request (the request) with extra {the postgres_connection}.
      the postgres_connection =
        Postgres Connection with a uri (value of environment_variable "DB_URI"):
          the username = value of environment_variable "DB_USERNAME",
          the password = value of environment_variable "DB_PASSWORD".

path to tasks {an [optional] page_token} =
  "/tasks[the query]".

  clarifying:
    the query =
      does the page_token match Something (the token)? then
        "?" ++ query string {the page_token = the token},
      otherwise
        "".
